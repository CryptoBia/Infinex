// Copyright (c) 2017-2018 The Infinex Core developers
// Distributed under the MIT/X11 software license, see the accompanying
// file COPYING or http://www.opensource.org/licenses/mit-license.php.

#ifndef TRADE_H
#define TRADE_H

#include <iostream>
#include <vector>
#include <map>
#include <memory>
#include <set>
#include "tradepair.h"
#include "userconnection.h"

class CUserTrade;
class CUserTradeSetting;
class CUserTradeManager;

class CActualTrade;
class CActualTradeSetting;
class CActualTradeManager;

typedef std::map<int, std::shared_ptr<CUserTrade>> mINTUT; //int and trade details

typedef std::pair<int, mINTUT> pULTIUTC;
extern std::map<std::string, pULTIUTC> mapUserTrades;

typedef std::map<uint64_t, mINTUT> mUTPIUTV; //price and user trade container
extern std::map<int, mUTPIUTV> mapBidUserTradeByPrice;
extern std::map<int, mUTPIUTV> mapAskUserTradeByPrice;

typedef std::map<std::string, mINTUT> mUTPKUTV; //user public key and user trade container
extern std::map<int, mUTPKUTV> mapBidUserTradeByPubkey;
extern std::map<int, mUTPKUTV> mapAskUserTradeByPubkey;

extern std::map<int, CUserTradeSetting> mapUserTradeSetting;
extern std::map<int, std::set<std::string>> mapUserTradeHash;
extern CUserTradeManager userTradeManager;

typedef std::map<int, std::shared_ptr<CActualTrade>> mATIAT;
typedef std::map<int, mATIAT> mUTImAT;

extern std::map<std::string, mUTImAT> mapUserActualTrades;

extern std::map<int, mATIAT> mapActualTradeByActualTradeID;
extern std::map<int, mUTImAT> mapActualTradeByUserTradeID;
extern std::map<int, std::vector<CActualTrade>> mapConflictTrade;
extern std::map<int, CActualTradeSetting> mapActualTradeSetting;
extern std::map<int, std::set<std::string>> mapActualTradeHash;
extern CActualTradeManager actualTradeManager;

class CCancelTrade
{
private:
	std::vector<unsigned char> userVchSig;
	std::vector<unsigned char> mnVchSig;

public:
	int nUserTradeID;
	int nTradePairID;
	std::string nUserPubKey;
	bool isBid;
	uint64_t nUserSubmitTime;
	int64_t nBalanceAmount;
	int64_t nBalanceQty;
	uint64_t nPrice;
	uint64_t nMNProcessTime;

	bool VerifyUserSignature();
	bool VerifyMNSignature();
	bool MNSign();
};

class CUserTradeSetting
{
public:
	int nTradePairID;
	uint32_t nMaxSubmissionTimeDiff;
	uint16_t nToStoreLowerLimit;
	uint16_t nToStoreUpperLimit;
	int nLastUserTradeID;
	uint64_t nLastUserTradeTime;
	std::string nMNPubKey;
	bool nInChargeOfBidBroadcast;
	bool nInChargeOfAskBroadcast;
	bool nIsInChargeOfProcessUserTrade;
	bool nIsInChargeOfMatchUserTrade;

	CUserTradeSetting(int nTradePairID, std::string nMNPubKey) :
		nTradePairID(nTradePairID),
		nMaxSubmissionTimeDiff(3000),
		nToStoreLowerLimit(50),
		nToStoreUpperLimit(100),
		nLastUserTradeID(0),
		nMNPubKey(nMNPubKey),
		nInChargeOfBidBroadcast(false),
		nInChargeOfAskBroadcast(false),
		nIsInChargeOfProcessUserTrade(false),
		nIsInChargeOfMatchUserTrade(false)
	{}

	CUserTradeSetting() :
		nTradePairID(0),
		nMaxSubmissionTimeDiff(3000),
		nToStoreLowerLimit(50),
		nToStoreUpperLimit(100),
		nLastUserTradeID(0),
		nMNPubKey(""),
		nInChargeOfBidBroadcast(false),
		nInChargeOfAskBroadcast(false),
		nIsInChargeOfProcessUserTrade(false),
		nIsInChargeOfMatchUserTrade(false)
	{}

	bool IsValidSubmissionTimeAndUpdate(uint64_t time);
};

class CUserTrade
{
private:
	std::vector<unsigned char> userVchSig;
	std::vector<unsigned char> mnBalanceVchSig;
	std::vector<unsigned char> mnTradeVchSig;

public:
	int nTradePairID;
	uint64_t nPrice;
	uint64_t nQuantity;
	uint64_t nAmount;
	bool nIsBid;
	int nTradeFee; //this is here to compare with trade pair fee & apply to whichever lower fee (benefit user)
	std::string nUserPubKey;
	uint64_t nTimeSubmit;
	std::string nUserHash;
	int nUserTradeID; //generated by balance MN
	int nPairTradeID; //generated by trade MN
	std::string nMNBalancePubKey;
	std::string nMNTradePubKey;
	int64_t nBalanceQty;
	int64_t nBalanceAmount;
	uint64_t nLastUpdate;

	CUserTrade(int nTradePairID, uint64_t nPrice, uint64_t nQuantity, bool nIsBid, int nTradeFee, std::string nUserPubKey, uint64_t nTimeSubmit, std::string nUserHash) :
		nTradePairID(nTradePairID),
		nPrice(nPrice),
		nQuantity(nQuantity),
		nAmount(nPrice * nQuantity),
		nIsBid(nIsBid),
		nTradeFee(nTradeFee),
		nUserPubKey(nUserPubKey),
		nTimeSubmit(nTimeSubmit),
		nUserHash(nUserHash),
		nUserTradeID(0),
		nPairTradeID(0),
		nMNBalancePubKey(""),
		nMNTradePubKey(""),
		nBalanceQty(nQuantity),
		nBalanceAmount(nAmount),
		nLastUpdate(0)
	{}

	CUserTrade() :
		nTradePairID(0),
		nPrice(0),
		nQuantity(0),
		nAmount(0),
		nIsBid(true),
		nTradeFee(0),
		nUserPubKey(""),
		nTimeSubmit(0),
		nUserHash(""),
		nUserTradeID(0),
		nPairTradeID(0),
		nMNBalancePubKey(""),
		nMNTradePubKey(""),
		nBalanceQty(0),
		nBalanceAmount(0),
		nLastUpdate(0)
	{}

	bool VerifyUserSignature();
	bool VerifyMNBalanceSignature();
	bool VerifyMNTradeSignature();
	bool MNBalanceSign();
	bool MNTradeSign();
	void RelayTo(CUserConnection& conn);
	void RelayToHandler();
};

class CUserTradeManager
{
private:
	std::vector<unsigned char> vchSig;

public:
	uint64_t GetAdjustedTime();
	void InitTradeCancelRequest(CCancelTrade& cancelTrade);
	void ProcessTradeCancelRequest(CCancelTrade& cancelTrade);
	void ReturnTradeCancelBalance(CCancelTrade& cancelTrade);
	void AssignBidBroadcastRole(int TradePairID);
	void AssignAskBroadcastRole(int TradePairID);
	void InitTradePair(int TradePairID);
	bool AssignNodeToProcessUserTrade(int TradePairID, bool toAssign = true);
	bool AssignNodeToMatchUserTrade(int TradePairID, bool toAssign = true);
	bool IsUserTradeInList(int TradePairID, std::string UserHash);
	void AddToUserTradeList(int TradePairID, std::string UserHash);
	uint64_t GetBidRequiredAmount(uint64_t Price, uint64_t Qty, int TradeFee);
	uint64_t GetAskExpectedAmount(uint64_t Price, uint64_t Qty, int TradeFee);
	bool IsSubmittedBidValid(const std::shared_ptr<CUserTrade>& userTrade, CTradePair& TradePair);
	bool IsSubmittedAskValid(const std::shared_ptr<CUserTrade>& userTrade, CTradePair& TradePair);
	bool IsSubmittedBidAmountValid(const std::shared_ptr<CUserTrade>& userTrade, int nTradeFee);
	bool IsSubmittedAskAmountValid(const std::shared_ptr<CUserTrade>& userTrade, int nTradeFee);
	void InputUserTrade(const std::shared_ptr<CUserTrade>& userTrade);
	bool ProcessUserTradeRequest(const std::shared_ptr<CUserTrade>& userTrade, CTradePair& tradePair);
	void SaveProcessedUserTrade(const std::shared_ptr<CUserTrade>& userTrade, CTradePair& tradePair);
	void InputMatchUserBuyRequest(const std::shared_ptr<CUserTrade>& userTrade, CTradePair& tradePair);
	void InputMatchUserSellRequest(const std::shared_ptr<CUserTrade>& userTrade, CTradePair& tradePair);
	bool ReduceBalanceQty(int TradePairID, int UserTradeID1, int UserTradeID2, uint64_t Qty);
	int64_t GetBalanceAmount(int TradePairID, uint64_t Price, int UserTradeID);
};

class CActualTradeSetting
{
public:
	int nTradePairID;
	uint32_t nMaxSubmissionTimeDiff;
	uint32_t nLastTradeMaxPreTimeDistance;
	uint16_t nToStoreLowerLimit;
	uint16_t nToStoreUpperLimit;
	int nLastActualTradeID;
	uint64_t nLastActualTradeTime;
	std::string nMNPubKey;
	bool ToVerifyActualTrade;
	bool nIsInChargeOfChartData;
	bool nIsInChargeOfMarketTradeHistory;
	bool nIsInChargeOfUserTradeHistory;
	bool nInChargeOfBidBroadcast;
	bool nInChargeOfAskBroadcast;

	CActualTradeSetting(int nTradePairID, std::string nMNPubKey) :
		nTradePairID(nTradePairID),
		nMaxSubmissionTimeDiff(3000),
		nLastTradeMaxPreTimeDistance(3000),
		nToStoreLowerLimit(50),
		nToStoreUpperLimit(100),
		nLastActualTradeID(0),
		nLastActualTradeTime(0),
		nMNPubKey(nMNPubKey),
		ToVerifyActualTrade(false),
		nIsInChargeOfChartData(false),
		nIsInChargeOfMarketTradeHistory(false),
		nIsInChargeOfUserTradeHistory(false),
		nInChargeOfBidBroadcast(false),
		nInChargeOfAskBroadcast(false)
	{}

	CActualTradeSetting():
		nTradePairID(0),
		nMaxSubmissionTimeDiff(3000),
		nLastTradeMaxPreTimeDistance(3000),
		nToStoreLowerLimit(50),
		nToStoreUpperLimit(100),
		nLastActualTradeID(0),
		nLastActualTradeTime(0),
		ToVerifyActualTrade(false),
		nIsInChargeOfChartData(false),
		nIsInChargeOfMarketTradeHistory(false),
		nIsInChargeOfUserTradeHistory(false),
		nInChargeOfBidBroadcast(false),
		nInChargeOfAskBroadcast(false)
	{}

	bool IsValidSubmissionTimeAndUpdate(uint64_t time);
};

class CActualTrade
{
private:
	std::vector<unsigned char> vchSig;

public:
	int nActualTradeID;
	int nTradePairID;
	int nUserTrade1;
	int nUserTrade2;
	uint64_t nTradePrice;
	uint64_t nTradeQty;
	uint64_t nTradeAmount;
	uint64_t nBidAmount;
	uint64_t nAskAmount;
	std::string nUserPubKey1;
	std::string nUserPubKey2;
	int64_t nFee1; //during promo period, we can provide rebate instead of trade fee to user
	int64_t nFee2; //during promo period, we can provide rebate instead of trade fee to user
	std::string nMasternodeInspector;
	std::string nCurrentHash;
	uint64_t nTradeTime;

	CActualTrade(int nTradePairID, int nUserTrade1, int nUserTrade2, uint64_t nTradePrice, uint64_t nTradeQty, uint64_t nBidAmount, uint64_t nAskAmount, std::string nUserPubKey1,
		std::string nUserPubKey2, int64_t nFee1, int64_t nFee2, uint64_t nTradeTime) :
		nActualTradeID(0),
		nTradePairID(nTradePairID),
		nUserTrade1(nUserTrade1),
		nUserTrade2(nUserTrade2),
		nTradePrice(nTradePrice),
		nTradeQty(nTradeQty),
		nTradeAmount(nTradePrice * nTradeQty),
		nBidAmount(nBidAmount),
		nAskAmount(nAskAmount),
		nUserPubKey1(nUserPubKey1),
		nUserPubKey2(nUserPubKey2),
		nFee1(nFee1),
		nFee2(nFee2),
		nMasternodeInspector(""),
		nCurrentHash(""),
		nTradeTime(nTradeTime)
	{}

	CActualTrade() :
		nActualTradeID(0),
		nTradePairID(0),
		nUserTrade1(0),
		nUserTrade2(0),
		nTradePrice(0),
		nTradeQty(0),
		nTradeAmount(0),
		nBidAmount(0),
		nAskAmount(0),
		nUserPubKey1(""),
		nUserPubKey2(""),
		nFee1(0),
		nFee2(0),
		nMasternodeInspector(""),
		nCurrentHash(""),
		nTradeTime(0)
	{}

	std::string GetHash();
	bool VerifySignature();
	bool Sign();
	bool Relay();
	bool InformConflictTrade(CNode* node);
};

class CActualTradeManager
{
public:
	CActualTradeManager() {}
	void AssignUserHistoryProviderRole(int TradePairID);
	void AssignMarketHistoryProviderRole(int TradePairID);
	void AssignChartDataProviderRole(int TradePairID);
	void AssignTradeProcessorRole(int TradePairID);
	bool GenerateActualTrade(std::shared_ptr<CActualTrade> actualTrade, CActualTradeSetting& actualTradeSetting);
	bool InputActualTrade(std::shared_ptr<CActualTrade> actualTrade, CActualTradeSetting& setting, CTradePair& tradePair);
	void InputActualTrade(std::shared_ptr<CActualTrade> actualTrade);
	bool InputActualTradeFromNode(std::shared_ptr<CActualTrade> actualTrade, CActualTradeSetting& setting, CTradePair& tradePair);
	bool IsActualTradeInList(int TradePairID, int ActualTradeID, std::string Hash);
	void InputNewTradePair(int TradePairID);	
	uint64_t GetTotalTradedQuantity(int TradePairID, int UserTradeID);
};

#endif